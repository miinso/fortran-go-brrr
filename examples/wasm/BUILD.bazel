# cross compilation to webassembly

load("@emsdk//emscripten_toolchain:wasm_cc_binary.bzl", "wasm_cc_binary")
load("@rules_cc//cc:defs.bzl", "cc_binary")
load("@rules_fortran//fortran:defs.bzl", "fortran_library")

# Example-3.A hello world
fortran_library(
    name = "hello",
    srcs = ["hello.f90"],  # compiles the .f90 to an object file (.o)
)
#  _QQmain:                    # internal Fortran program entry (called by main)
#    (whole bunch of fortran asm...)
#  main:                       # the standard C entry point
#    call   5e <main+0xe>      # call 1: _FortranAProgramStart
#    call   63 <main+0x13>     # call 2: _QQmain
#    call   68 <main+0x18>     # call 3: _FortranAProgramEndStatement
#    xor    %eax,%eax
#    ret

# this `cc_binary` just wraps fortran intermediaries. main entry point from the
# original source is preserved. in this case, `main` and `_QQmain`.
# since there's no C main(), the linker picks up main from the Fortran library
cc_binary(
    name = "hello_cc",
    srcs = [],  # look ma no source!
    deps = [":hello"],
)

# produce final wasm output
wasm_cc_binary(
    name = "hello_wasm",
    cc_target = ":hello_cc",
    outputs = [
        "hello_cc.js",
        "hello_cc.wasm",
    ],
)

# Example-3.B full lapacke client, only single for faster build
cc_binary(
    name = "full",
    srcs = [
        "full.c",
    ],
    deps = [
        "@blas//:single",
        "@lapack//:single",
        "@lapacke//:single",
    ],
)

wasm_cc_binary(
    name = "full_wasm",
    cc_target = ":full",
    outputs = [
        "full.js",
        "full.wasm",
    ],
)
